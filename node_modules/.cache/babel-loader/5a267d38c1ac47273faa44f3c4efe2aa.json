{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport clamp from 'lodash-es/clamp';\nimport debounce from 'lodash-es/debounce';\nimport { ScrollbarPlugin } from 'smooth-scrollbar';\nimport { Bounce } from './bounce';\nimport { Glow } from './glow';\nexport var OverscrollEffect;\n\n(function (OverscrollEffect) {\n  OverscrollEffect[\"BOUNCE\"] = \"bounce\";\n  OverscrollEffect[\"GLOW\"] = \"glow\";\n})(OverscrollEffect || (OverscrollEffect = {}));\n\nvar ALLOWED_EVENTS = /wheel|touch/;\n\nvar OverscrollPlugin =\n/** @class */\nfunction (_super) {\n  __extends(OverscrollPlugin, _super);\n\n  function OverscrollPlugin() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this._glow = new Glow(_this.scrollbar);\n    _this._bounce = new Bounce(_this.scrollbar);\n    _this._wheelScrollBack = {\n      x: false,\n      y: false\n    };\n    _this._lockWheel = {\n      x: false,\n      y: false\n    };\n    _this._touching = false;\n    _this._amplitude = {\n      x: 0,\n      y: 0\n    };\n    _this._position = {\n      x: 0,\n      y: 0\n    }; // since we can't detect whether user release touchpad\n    // handle it with debounce is the best solution now, as a trade-off\n\n    _this._releaseWheel = debounce(function () {\n      _this._lockWheel.x = false;\n      _this._lockWheel.y = false;\n    }, 30);\n    return _this;\n  }\n\n  Object.defineProperty(OverscrollPlugin.prototype, \"_isWheelLocked\", {\n    get: function get() {\n      return this._lockWheel.x || this._lockWheel.y;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OverscrollPlugin.prototype, \"_enabled\", {\n    get: function get() {\n      return !!this.options.effect;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  OverscrollPlugin.prototype.onInit = function () {\n    var _a = this,\n        _glow = _a._glow,\n        options = _a.options,\n        scrollbar = _a.scrollbar; // observe\n\n\n    var effect = options.effect;\n    Object.defineProperty(options, 'effect', {\n      get: function get() {\n        return effect;\n      },\n      set: function set(val) {\n        if (!val) {\n          effect = undefined;\n          return;\n        }\n\n        if (val !== OverscrollEffect.BOUNCE && val !== OverscrollEffect.GLOW) {\n          throw new TypeError(\"unknow overscroll effect: \" + val);\n        }\n\n        effect = val;\n        scrollbar.options.continuousScrolling = false;\n\n        if (val === OverscrollEffect.GLOW) {\n          _glow.mount();\n\n          _glow.adjust();\n        } else {\n          _glow.unmount();\n        }\n      }\n    });\n    options.effect = effect; // init\n  };\n\n  OverscrollPlugin.prototype.onUpdate = function () {\n    if (this.options.effect === OverscrollEffect.GLOW) {\n      this._glow.adjust();\n    }\n  };\n\n  OverscrollPlugin.prototype.onRender = function (remainMomentum) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (this.scrollbar.options.continuousScrolling) {\n      // turn off continuous scrolling\n      this.scrollbar.options.continuousScrolling = false;\n    }\n\n    var nextX = remainMomentum.x,\n        nextY = remainMomentum.y; // transfer remain momentum to overscroll\n\n    if (!this._amplitude.x && this._willOverscroll('x', remainMomentum.x)) {\n      nextX = 0;\n\n      this._absorbMomentum('x', remainMomentum.x);\n    }\n\n    if (!this._amplitude.y && this._willOverscroll('y', remainMomentum.y)) {\n      nextY = 0;\n\n      this._absorbMomentum('y', remainMomentum.y);\n    }\n\n    this.scrollbar.setMomentum(nextX, nextY);\n\n    this._render();\n  };\n\n  OverscrollPlugin.prototype.transformDelta = function (delta, fromEvent) {\n    this._lastEventType = fromEvent.type;\n\n    if (!this._enabled || !ALLOWED_EVENTS.test(fromEvent.type)) {\n      return delta;\n    }\n\n    if (this._isWheelLocked && /wheel/.test(fromEvent.type)) {\n      this._releaseWheel();\n\n      if (this._willOverscroll('x', delta.x)) {\n        delta.x = 0;\n      }\n\n      if (this._willOverscroll('y', delta.y)) {\n        delta.y = 0;\n      }\n    }\n\n    var nextX = delta.x,\n        nextY = delta.y;\n\n    if (this._willOverscroll('x', delta.x)) {\n      nextX = 0;\n\n      this._addAmplitude('x', delta.x);\n    }\n\n    if (this._willOverscroll('y', delta.y)) {\n      nextY = 0;\n\n      this._addAmplitude('y', delta.y);\n    }\n\n    switch (fromEvent.type) {\n      case 'touchstart':\n      case 'touchmove':\n        this._touching = true;\n\n        this._glow.recordTouch(fromEvent);\n\n        break;\n\n      case 'touchcancel':\n      case 'touchend':\n        this._touching = false;\n        break;\n    }\n\n    return {\n      x: nextX,\n      y: nextY\n    };\n  };\n\n  OverscrollPlugin.prototype._willOverscroll = function (direction, delta) {\n    if (!delta) {\n      return false;\n    } // away from origin\n\n\n    if (this._position[direction]) {\n      return true;\n    }\n\n    var offset = this.scrollbar.offset[direction];\n    var limit = this.scrollbar.limit[direction];\n\n    if (limit === 0) {\n      return false;\n    } // cond:\n    //  1. next scrolling position is supposed to stay unchange\n    //  2. current position is on the edge\n\n\n    return clamp(offset + delta, 0, limit) === offset && (offset === 0 || offset === limit);\n  };\n\n  OverscrollPlugin.prototype._absorbMomentum = function (direction, remainMomentum) {\n    var _a = this,\n        options = _a.options,\n        _lastEventType = _a._lastEventType,\n        _amplitude = _a._amplitude;\n\n    if (!ALLOWED_EVENTS.test(_lastEventType)) {\n      return;\n    }\n\n    _amplitude[direction] = clamp(remainMomentum, -options.maxOverscroll, options.maxOverscroll);\n  };\n\n  OverscrollPlugin.prototype._addAmplitude = function (direction, delta) {\n    var _a = this,\n        options = _a.options,\n        scrollbar = _a.scrollbar,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    var currentAmp = _amplitude[direction];\n    var isOpposite = delta * currentAmp < 0;\n    var friction;\n\n    if (isOpposite) {\n      // opposite direction\n      friction = 0;\n    } else {\n      friction = this._wheelScrollBack[direction] ? 1 : Math.abs(currentAmp / options.maxOverscroll);\n    }\n\n    var amp = currentAmp + delta * (1 - friction);\n    _amplitude[direction] = scrollbar.offset[direction] === 0 ?\n    /*    top | left  */\n    clamp(amp, -options.maxOverscroll, 0) :\n    /* bottom | right */\n    clamp(amp, 0, options.maxOverscroll);\n\n    if (isOpposite) {\n      // scroll back\n      _position[direction] = _amplitude[direction];\n    }\n  };\n\n  OverscrollPlugin.prototype._render = function () {\n    var _a = this,\n        options = _a.options,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    if (this._enabled && (_amplitude.x || _amplitude.y || _position.x || _position.y)) {\n      var nextX = this._nextAmp('x');\n\n      var nextY = this._nextAmp('y');\n\n      _amplitude.x = nextX.amplitude;\n      _position.x = nextX.position;\n      _amplitude.y = nextY.amplitude;\n      _position.y = nextY.position;\n\n      switch (options.effect) {\n        case OverscrollEffect.BOUNCE:\n          this._bounce.render(_position);\n\n          break;\n\n        case OverscrollEffect.GLOW:\n          this._glow.render(_position, this.options.glowColor);\n\n          break;\n      }\n\n      if (typeof options.onScroll === 'function') {\n        options.onScroll.call(this, __assign({}, _position));\n      }\n    }\n  };\n\n  OverscrollPlugin.prototype._nextAmp = function (direction) {\n    var _a = this,\n        options = _a.options,\n        _amplitude = _a._amplitude,\n        _position = _a._position;\n\n    var t = 1 - options.damping;\n    var amp = _amplitude[direction];\n    var pos = _position[direction];\n    var nextAmp = this._touching ? amp : amp * t | 0;\n    var distance = nextAmp - pos;\n    var nextPos = pos + distance - (distance * t | 0);\n\n    if (!this._touching && Math.abs(nextPos) < Math.abs(pos)) {\n      this._wheelScrollBack[direction] = true;\n    }\n\n    if (this._wheelScrollBack[direction] && Math.abs(nextPos) <= 1) {\n      this._wheelScrollBack[direction] = false;\n      this._lockWheel[direction] = true;\n    }\n\n    return {\n      amplitude: nextAmp,\n      position: nextPos\n    };\n  };\n\n  OverscrollPlugin.pluginName = 'overscroll';\n  OverscrollPlugin.defaultOptions = {\n    effect: OverscrollEffect.BOUNCE,\n    onScroll: undefined,\n    damping: 0.2,\n    maxOverscroll: 150,\n    glowColor: '#87ceeb'\n  };\n  return OverscrollPlugin;\n}(ScrollbarPlugin);\n\nexport default OverscrollPlugin;","map":{"version":3,"mappings":"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","names":["clamp","debounce","ScrollbarPlugin","Bounce","Glow","OverscrollEffect","ALLOWED_EVENTS","__extends","_this","scrollbar","x","y","_lockWheel","Object","OverscrollPlugin","options","effect","_glow","defineProperty","get","set","val","undefined","BOUNCE","GLOW","TypeError","continuousScrolling","mount","adjust","unmount","remainMomentum","_enabled","nextY","_amplitude","_willOverscroll","nextX","_absorbMomentum","setMomentum","_render","delta","fromEvent","_lastEventType","type","test","_isWheelLocked","_releaseWheel","_addAmplitude","_touching","recordTouch","direction","_position","offset","limit","maxOverscroll","currentAmp","isOpposite","friction","_wheelScrollBack","Math","abs","amp","_nextAmp","amplitude","position","_bounce","render","glowColor","onScroll","call","__assign","t","damping","pos","nextAmp","distance","nextPos"],"sources":["/home/mohammad/Desktop/MARS-main/node_modules/smooth-scrollbar/src/plugins/overscroll/index.ts"],"sourcesContent":["import clamp from 'lodash-es/clamp';\nimport debounce from 'lodash-es/debounce';\nimport { ScrollbarPlugin } from 'smooth-scrollbar';\nimport { Bounce } from './bounce';\nimport { Glow } from './glow';\n\nexport enum OverscrollEffect {\n  BOUNCE = 'bounce',\n  GLOW = 'glow',\n}\n\nexport type Data2d = {\n  x: number,\n  y: number,\n};\n\nexport type OnScrollCallback = (this: OverscrollPlugin, position: Data2d) => void;\n\nexport type OverscrollOptions = {\n  effect?: OverscrollEffect,\n  onScroll?: OnScrollCallback,\n  damping: number,\n  maxOverscroll: number,\n  glowColor: string,\n};\n\nconst ALLOWED_EVENTS = /wheel|touch/;\n\nexport default class OverscrollPlugin extends ScrollbarPlugin {\n  static pluginName = 'overscroll';\n\n  static defaultOptions: OverscrollOptions = {\n    effect: OverscrollEffect.BOUNCE,\n    onScroll: undefined,\n    damping: 0.2,\n    maxOverscroll: 150,\n    glowColor: '#87ceeb',\n  };\n\n  options: OverscrollOptions;\n\n  private _glow = new Glow(this.scrollbar);\n  private _bounce = new Bounce(this.scrollbar);\n\n  private _wheelScrollBack = {\n    x: false,\n    y: false,\n  };\n  private _lockWheel = {\n    x: false,\n    y: false,\n  };\n\n  private get _isWheelLocked() {\n    return this._lockWheel.x || this._lockWheel.y;\n  }\n\n  private _touching = false;\n\n  private _lastEventType: string;\n\n  private _amplitude = {\n    x: 0,\n    y: 0,\n  };\n\n  private _position = {\n    x: 0,\n    y: 0,\n  };\n\n  private get _enabled() {\n    return !!this.options.effect;\n  }\n\n  // since we can't detect whether user release touchpad\n  // handle it with debounce is the best solution now, as a trade-off\n  private _releaseWheel = debounce(() => {\n    this._lockWheel.x = false;\n    this._lockWheel.y = false;\n  }, 30);\n\n  onInit() {\n    const {\n      _glow,\n      options,\n      scrollbar,\n    } = this;\n\n    // observe\n    let effect = options.effect;\n\n    Object.defineProperty(options, 'effect', {\n      get() {\n        return effect;\n      },\n      set(val) {\n        if (!val) {\n          effect = undefined;\n          return;\n        }\n\n        if (val !== OverscrollEffect.BOUNCE && val !== OverscrollEffect.GLOW) {\n          throw new TypeError(`unknow overscroll effect: ${val}`);\n        }\n\n        effect = val;\n\n        scrollbar.options.continuousScrolling = false;\n\n        if (val === OverscrollEffect.GLOW) {\n          _glow.mount();\n          _glow.adjust();\n        } else {\n          _glow.unmount();\n        }\n      },\n    });\n\n    options.effect = effect; // init\n  }\n\n  onUpdate() {\n    if (this.options.effect === OverscrollEffect.GLOW) {\n      this._glow.adjust();\n    }\n  }\n\n  onRender(remainMomentum: Data2d) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (this.scrollbar.options.continuousScrolling) {\n      // turn off continuous scrolling\n      this.scrollbar.options.continuousScrolling = false;\n    }\n\n    let { x: nextX, y: nextY } = remainMomentum;\n\n    // transfer remain momentum to overscroll\n    if (!this._amplitude.x &&\n        this._willOverscroll('x', remainMomentum.x)\n    ) {\n      nextX = 0;\n\n      this._absorbMomentum('x', remainMomentum.x);\n    }\n\n    if (!this._amplitude.y &&\n        this._willOverscroll('y', remainMomentum.y)\n    ) {\n      nextY = 0;\n\n      this._absorbMomentum('y', remainMomentum.y);\n    }\n\n    this.scrollbar.setMomentum(nextX, nextY);\n    this._render();\n  }\n\n  transformDelta(delta: Data2d, fromEvent: Event): Data2d {\n    this._lastEventType = fromEvent.type;\n\n    if (!this._enabled || !ALLOWED_EVENTS.test(fromEvent.type)) {\n      return delta;\n    }\n\n    if (this._isWheelLocked && /wheel/.test(fromEvent.type)) {\n      this._releaseWheel();\n\n      if (this._willOverscroll('x', delta.x)) {\n        delta.x = 0;\n      }\n\n      if (this._willOverscroll('y', delta.y)) {\n        delta.y = 0;\n      }\n    }\n\n    let { x: nextX, y: nextY } = delta;\n\n    if (this._willOverscroll('x', delta.x)) {\n      nextX = 0;\n      this._addAmplitude('x', delta.x);\n    }\n\n    if (this._willOverscroll('y', delta.y)) {\n      nextY = 0;\n      this._addAmplitude('y', delta.y);\n    }\n\n    switch (fromEvent.type) {\n      case 'touchstart':\n      case 'touchmove':\n        this._touching = true;\n        this._glow.recordTouch(fromEvent as TouchEvent);\n        break;\n\n      case 'touchcancel':\n      case 'touchend':\n        this._touching = false;\n        break;\n    }\n\n    return {\n      x: nextX,\n      y: nextY,\n    };\n  }\n\n  private _willOverscroll(direction: 'x' | 'y', delta: number): boolean {\n    if (!delta) {\n      return false;\n    }\n\n    // away from origin\n    if (this._position[direction]) {\n      return true;\n    }\n\n    const offset = this.scrollbar.offset[direction];\n    const limit = this.scrollbar.limit[direction];\n\n    if (limit === 0) {\n      return false;\n    }\n\n    // cond:\n    //  1. next scrolling position is supposed to stay unchange\n    //  2. current position is on the edge\n    return clamp(offset + delta, 0, limit) === offset &&\n        (offset === 0 || offset === limit);\n  }\n\n  private _absorbMomentum(direction: 'x' | 'y', remainMomentum: number) {\n    const {\n      options,\n      _lastEventType,\n      _amplitude,\n    } = this;\n\n    if (!ALLOWED_EVENTS.test(_lastEventType)) {\n      return;\n    }\n\n    _amplitude[direction] = clamp(remainMomentum, -options.maxOverscroll, options.maxOverscroll);\n  }\n\n  private _addAmplitude(direction: 'x' | 'y', delta: number) {\n    const {\n      options,\n      scrollbar,\n      _amplitude,\n      _position,\n    } = this;\n\n    const currentAmp = _amplitude[direction];\n\n    const isOpposite = delta * currentAmp < 0;\n\n    let friction: number;\n\n    if (isOpposite) {\n      // opposite direction\n      friction = 0;\n    } else {\n      friction = this._wheelScrollBack[direction] ?\n        1 : Math.abs(currentAmp / options.maxOverscroll);\n    }\n\n    const amp = currentAmp + delta * (1 - friction);\n\n    _amplitude[direction] = scrollbar.offset[direction] === 0 ?\n      /*    top | left  */ clamp(amp, -options.maxOverscroll, 0) :\n      /* bottom | right */ clamp(amp, 0, options.maxOverscroll);\n\n    if (isOpposite) {\n      // scroll back\n      _position[direction] = _amplitude[direction];\n    }\n  }\n\n  private _render() {\n    const {\n      options,\n      _amplitude,\n      _position,\n    } = this;\n\n    if (this._enabled &&\n        (_amplitude.x || _amplitude.y || _position.x || _position.y)\n    ) {\n      const nextX = this._nextAmp('x');\n      const nextY = this._nextAmp('y');\n\n      _amplitude.x = nextX.amplitude;\n      _position.x = nextX.position;\n\n      _amplitude.y = nextY.amplitude;\n      _position.y = nextY.position;\n\n      switch (options.effect) {\n        case OverscrollEffect.BOUNCE:\n          this._bounce.render(_position);\n          break;\n\n        case OverscrollEffect.GLOW:\n          this._glow.render(_position, this.options.glowColor);\n          break;\n      }\n\n      if (typeof options.onScroll === 'function') {\n        options.onScroll.call(this, { ..._position });\n      }\n    }\n  }\n\n  private _nextAmp(direction: 'x' | 'y'): { amplitude: number, position: number } {\n    const {\n      options,\n      _amplitude,\n      _position,\n    } = this;\n\n    const t = 1 - options.damping;\n    const amp = _amplitude[direction];\n    const pos = _position[direction];\n\n    const nextAmp = this._touching ? amp : (amp * t | 0);\n    const distance = nextAmp - pos;\n    const nextPos = pos + distance - (distance * t | 0);\n\n    if (!this._touching && Math.abs(nextPos) < Math.abs(pos)) {\n      this._wheelScrollBack[direction] = true;\n    }\n\n    if (this._wheelScrollBack[direction] && Math.abs(nextPos) <= 1) {\n      this._wheelScrollBack[direction] = false;\n      this._lockWheel[direction] = true;\n    }\n\n    return {\n      amplitude: nextAmp,\n      position: nextPos,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}