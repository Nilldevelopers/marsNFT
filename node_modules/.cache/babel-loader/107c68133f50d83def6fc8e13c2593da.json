{"ast":null,"code":"import { __assign, __decorate } from \"tslib\";\nimport clamp from 'lodash-es/clamp';\nimport { Options } from './options';\nimport { setStyle, clearEventsOn } from './utils/';\nimport { debounce } from './decorators/';\nimport { TrackController } from './track/';\nimport { getSize, update, isVisible } from './geometry/';\nimport { scrollTo, setPosition, scrollIntoView } from './scrolling/';\nimport { initPlugins } from './plugin';\nimport * as eventHandlers from './events/'; // DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\n\nexport var scrollbarMap = new Map();\n\nvar Scrollbar =\n/** @class */\nfunction () {\n  function Scrollbar(containerEl, options) {\n    var _this = this;\n    /**\n     * Current scrolling offsets\n     */\n\n\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    /**\n     * Max-allowed scrolling offsets\n     */\n\n    this.limit = {\n      x: Infinity,\n      y: Infinity\n    };\n    /**\n     * Container bounding rect\n     */\n\n    this.bounding = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }; // private _observer: ResizeObserver;\n\n    this._plugins = [];\n    this._momentum = {\n      x: 0,\n      y: 0\n    };\n    this._listeners = new Set();\n    this.containerEl = containerEl;\n    var contentEl = this.contentEl = document.createElement('div');\n    this.options = new Options(options); // mark as a scroll element\n\n    containerEl.setAttribute('data-scrollbar', 'true'); // make container focusable\n\n    containerEl.setAttribute('tabindex', '-1');\n    setStyle(containerEl, {\n      overflow: 'hidden',\n      outline: 'none'\n    }); // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    } // mount content\n\n\n    contentEl.className = 'scroll-content';\n    Array.from(containerEl.childNodes).forEach(function (node) {\n      contentEl.appendChild(node);\n    });\n    containerEl.appendChild(contentEl); // attach track\n\n    this.track = new TrackController(this); // initial measuring\n\n    this.size = this.getSize(); // init plugins\n\n    this._plugins = initPlugins(this, this.options.plugins); // preserve scroll offset\n\n    var scrollLeft = containerEl.scrollLeft,\n        scrollTop = containerEl.scrollTop;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true\n    }); // FIXME: update typescript\n\n    var ResizeObserver = window.ResizeObserver; // observe\n\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(function () {\n        _this.update();\n      });\n\n      this._observer.observe(contentEl);\n    }\n\n    scrollbarMap.set(containerEl, this); // wait for DOM ready\n\n    requestAnimationFrame(function () {\n      _this._init();\n    });\n  }\n\n  Object.defineProperty(Scrollbar.prototype, \"parent\", {\n    /**\n     * Parent scrollbar\n     */\n    get: function get() {\n      var elem = this.containerEl.parentElement;\n\n      while (elem) {\n        var parentScrollbar = scrollbarMap.get(elem);\n\n        if (parentScrollbar) {\n          return parentScrollbar;\n        }\n\n        elem = elem.parentElement;\n      }\n\n      return null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollTop\", {\n    /**\n     * Gets or sets `scrollbar.offset.y`\n     */\n    get: function get() {\n      return this.offset.y;\n    },\n    set: function set(y) {\n      this.setPosition(this.scrollLeft, y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Scrollbar.prototype, \"scrollLeft\", {\n    /**\n     * Gets or sets `scrollbar.offset.x`\n     */\n    get: function get() {\n      return this.offset.x;\n    },\n    set: function set(x) {\n      this.setPosition(x, this.scrollTop);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n\n  Scrollbar.prototype.getSize = function () {\n    return getSize(this);\n  };\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n\n\n  Scrollbar.prototype.update = function () {\n    update(this);\n\n    this._plugins.forEach(function (plugin) {\n      plugin.onUpdate();\n    });\n  };\n  /**\n   * Checks if an element is visible in the current view area\n   */\n\n\n  Scrollbar.prototype.isVisible = function (elem) {\n    return isVisible(this, elem);\n  };\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n\n\n  Scrollbar.prototype.setPosition = function (x, y, options) {\n    var _this = this;\n\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var status = setPosition(this, x, y);\n\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n\n    this._listeners.forEach(function (fn) {\n      fn.call(_this, status);\n    });\n  };\n  /**\n   * Scrolls to given position with easing function\n   */\n\n\n  Scrollbar.prototype.scrollTo = function (x, y, duration, options) {\n    if (x === void 0) {\n      x = this.offset.x;\n    }\n\n    if (y === void 0) {\n      y = this.offset.y;\n    }\n\n    if (duration === void 0) {\n      duration = 0;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    scrollTo(this, x, y, duration, options);\n  };\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n\n\n  Scrollbar.prototype.scrollIntoView = function (elem, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    scrollIntoView(this, elem, options);\n  };\n  /**\n   * Adds scrolling listener\n   */\n\n\n  Scrollbar.prototype.addListener = function (fn) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n\n    this._listeners.add(fn);\n  };\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n\n\n  Scrollbar.prototype.removeListener = function (fn) {\n    this._listeners.delete(fn);\n  };\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n\n\n  Scrollbar.prototype.addTransformableMomentum = function (x, y, fromEvent, callback) {\n    this._updateDebounced();\n\n    var finalDelta = this._plugins.reduce(function (delta, plugin) {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, {\n      x: x,\n      y: y\n    });\n\n    var willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  };\n  /**\n   * Increases scrollbar's momentum\n   */\n\n\n  Scrollbar.prototype.addMomentum = function (x, y) {\n    this.setMomentum(this._momentum.x + x, this._momentum.y + y);\n  };\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n\n\n  Scrollbar.prototype.setMomentum = function (x, y) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    this._momentum.x = x;\n    this._momentum.y = y;\n  };\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n\n\n  Scrollbar.prototype.updatePluginOptions = function (pluginName, options) {\n    this._plugins.forEach(function (plugin) {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  };\n\n  Scrollbar.prototype.destroy = function () {\n    var _a = this,\n        containerEl = _a.containerEl,\n        contentEl = _a.contentEl;\n\n    clearEventsOn(this);\n\n    this._listeners.clear();\n\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n\n    scrollbarMap.delete(this.containerEl); // restore contents\n\n    var childNodes = Array.from(contentEl.childNodes);\n\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n\n    childNodes.forEach(function (el) {\n      containerEl.appendChild(el);\n    }); // reset scroll position\n\n    setStyle(containerEl, {\n      overflow: ''\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft; // invoke plugin.onDestroy\n\n    this._plugins.forEach(function (plugin) {\n      plugin.onDestroy();\n    });\n\n    this._plugins.length = 0;\n  };\n\n  Scrollbar.prototype._init = function () {\n    var _this = this;\n\n    this.update(); // init evet handlers\n\n    Object.keys(eventHandlers).forEach(function (prop) {\n      eventHandlers[prop](_this);\n    }); // invoke `plugin.onInit`\n\n    this._plugins.forEach(function (plugin) {\n      plugin.onInit();\n    });\n\n    this._render();\n  };\n\n  Scrollbar.prototype._updateDebounced = function () {\n    this.update();\n  }; // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n\n\n  Scrollbar.prototype._shouldPropagateMomentum = function (deltaX, deltaY) {\n    if (deltaX === void 0) {\n      deltaX = 0;\n    }\n\n    if (deltaY === void 0) {\n      deltaY = 0;\n    }\n\n    var _a = this,\n        options = _a.options,\n        offset = _a.offset,\n        limit = _a.limit;\n\n    if (!options.continuousScrolling) return false; // force an update when scrollbar is \"unscrollable\", see #106\n\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n\n    var destX = clamp(deltaX + offset.x, 0, limit.x);\n    var destY = clamp(deltaY + offset.y, 0, limit.y);\n    var res = true; // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n\n    res = res && destX === offset.x;\n    res = res && destY === offset.y; // current offsets are on the edge\n\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n    return res;\n  };\n\n  Scrollbar.prototype._render = function () {\n    var _momentum = this._momentum;\n\n    if (_momentum.x || _momentum.y) {\n      var nextX = this._nextTick('x');\n\n      var nextY = this._nextTick('y');\n\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n      this.setPosition(nextX.position, nextY.position);\n    }\n\n    var remain = __assign({}, this._momentum);\n\n    this._plugins.forEach(function (plugin) {\n      plugin.onRender(remain);\n    });\n\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  };\n\n  Scrollbar.prototype._nextTick = function (direction) {\n    var _a = this,\n        options = _a.options,\n        offset = _a.offset,\n        _momentum = _a._momentum;\n\n    var current = offset[direction];\n    var remain = _momentum[direction];\n\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain\n      };\n    }\n\n    var nextMomentum = remain * (1 - options.damping);\n\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum\n    };\n  };\n\n  __decorate([debounce(100, {\n    leading: true\n  })], Scrollbar.prototype, \"_updateDebounced\", null);\n\n  return Scrollbar;\n}();\n\nexport { Scrollbar };","map":{"version":3,"mappings":"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","names":["clamp","Options","setStyle","clearEventsOn","debounce","TrackController","getSize","update","isVisible","scrollTo","setPosition","scrollIntoView","initPlugins","eventHandlers","scrollbarMap","Map","containerEl","options","x","y","Infinity","top","right","bottom","left","Set","contentEl","document","createElement","setAttribute","overflow","outline","window","navigator","msPointerEnabled","style","msTouchAction","className","Array","from","childNodes","forEach","node","appendChild","track","size","_plugins","plugins","scrollTop","scrollLeft","withoutCallbacks","ResizeObserver","_observer","_this","observe","set","requestAnimationFrame","_init","Object","Scrollbar","elem","parentElement","parentScrollbar","get","offset","plugin","onUpdate","status","_listeners","fn","call","duration","TypeError","add","delete","fromEvent","callback","_updateDebounced","finalDelta","reduce","delta","transformDelta","willScroll","_shouldPropagateMomentum","addMomentum","setMomentum","_momentum","limit","renderByPixels","Math","round","pluginName","name","assign","clear","cancelAnimationFrame","_renderID","disconnect","firstChild","removeChild","el","onDestroy","length","keys","prop","onInit","_render","deltaX","deltaY","continuousScrolling","destX","destY","res","nextX","_nextTick","nextY","momentum","position","remain","onRender","bind","direction","current","abs","nextMomentum","damping","__decorate","leading"],"sources":["/home/mohammad/Desktop/MARS-main/node_modules/smooth-scrollbar/src/scrollbar.ts"],"sourcesContent":["import clamp from 'lodash-es/clamp';\n\nimport { Options } from './options';\n\nimport {\n  setStyle,\n  clearEventsOn,\n} from './utils/';\n\nimport {\n  debounce,\n} from './decorators/';\n\nimport {\n  TrackController,\n} from './track/';\n\nimport {\n  getSize,\n  update,\n  isVisible,\n} from './geometry/';\n\nimport {\n  scrollTo,\n  setPosition,\n  scrollIntoView,\n} from './scrolling/';\n\nimport {\n  initPlugins,\n} from './plugin';\n\nimport * as eventHandlers from './events/';\n\nimport * as I from './interfaces/';\n\n// DO NOT use WeakMap here\n// .getAll() methods requires `scrollbarMap.values()`\nexport const scrollbarMap = new Map<HTMLElement, Scrollbar>();\n\nexport class Scrollbar implements I.Scrollbar {\n  /**\n   * Options for current scrollbar instancs\n   */\n  readonly options: Options;\n\n  readonly track: TrackController;\n\n  /**\n   * The element that you initialized scrollbar to\n   */\n  readonly containerEl: HTMLElement;\n\n  /**\n   * The wrapper element that contains your contents\n   */\n  readonly contentEl: HTMLElement;\n\n  /**\n   * Geometry infomation for current scrollbar instance\n   */\n  size: I.ScrollbarSize;\n\n  /**\n   * Current scrolling offsets\n   */\n  offset = {\n    x: 0,\n    y: 0,\n  };\n\n  /**\n   * Max-allowed scrolling offsets\n   */\n  limit = {\n    x: Infinity,\n    y: Infinity,\n  };\n\n  /**\n   * Container bounding rect\n   */\n  bounding = {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n  };\n\n  /**\n   * Parent scrollbar\n   */\n  get parent() {\n    let elem = this.containerEl.parentElement;\n\n    while (elem) {\n      const parentScrollbar = scrollbarMap.get(elem);\n\n      if (parentScrollbar) {\n        return parentScrollbar;\n      }\n\n      elem = elem.parentElement;\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets or sets `scrollbar.offset.y`\n   */\n  get scrollTop() {\n    return this.offset.y;\n  }\n  set scrollTop(y: number) {\n    this.setPosition(this.scrollLeft, y);\n  }\n\n  /**\n   * Gets or sets `scrollbar.offset.x`\n   */\n  get scrollLeft() {\n    return this.offset.x;\n  }\n  set scrollLeft(x: number) {\n    this.setPosition(x, this.scrollTop);\n  }\n\n  private _renderID: number;\n  private _observer: any; // FIXME: we need to update typescript version to support `ResizeObserver`\n  // private _observer: ResizeObserver;\n  private _plugins: I.ScrollbarPlugin[] = [];\n\n  private _momentum = { x: 0, y: 0 };\n  private _listeners = new Set<I.ScrollListener>();\n\n  constructor(\n    containerEl: HTMLElement,\n    options?: Partial<I.ScrollbarOptions>,\n  ) {\n    this.containerEl = containerEl;\n    const contentEl = this.contentEl = document.createElement('div');\n\n    this.options = new Options(options);\n\n    // mark as a scroll element\n    containerEl.setAttribute('data-scrollbar', 'true');\n\n    // make container focusable\n    containerEl.setAttribute('tabindex', '-1');\n    setStyle(containerEl, {\n      overflow: 'hidden',\n      outline: 'none',\n    });\n\n    // enable touch event capturing in IE, see:\n    // https://github.com/idiotWu/smooth-scrollbar/issues/39\n    if (window.navigator.msPointerEnabled) {\n      containerEl.style.msTouchAction = 'none';\n    }\n\n    // mount content\n    contentEl.className = 'scroll-content';\n\n    Array.from(containerEl.childNodes).forEach((node) => {\n      contentEl.appendChild(node);\n    });\n\n    containerEl.appendChild(contentEl);\n\n    // attach track\n    this.track = new TrackController(this);\n\n    // initial measuring\n    this.size = this.getSize();\n\n    // init plugins\n    this._plugins = initPlugins(this, this.options.plugins);\n\n    // preserve scroll offset\n    const { scrollLeft, scrollTop } = containerEl;\n    containerEl.scrollLeft = containerEl.scrollTop = 0;\n    this.setPosition(scrollLeft, scrollTop, {\n      withoutCallbacks: true,\n    });\n\n    // FIXME: update typescript\n    const ResizeObserver = (window as any).ResizeObserver;\n\n    // observe\n    if (typeof ResizeObserver === 'function') {\n      this._observer = new ResizeObserver(() => {\n        this.update();\n      });\n\n      this._observer.observe(contentEl);\n    }\n\n    scrollbarMap.set(containerEl, this);\n\n    // wait for DOM ready\n    requestAnimationFrame(() => {\n      this._init();\n    });\n  }\n\n  /**\n   * Returns the size of the scrollbar container element\n   * and the content wrapper element\n   */\n  getSize(): I.ScrollbarSize {\n    return getSize(this);\n  }\n\n  /**\n   * Forces scrollbar to update geometry infomation.\n   *\n   * By default, scrollbars are automatically updated with `100ms` debounce (or `MutationObserver` fires).\n   * You can call this method to force an update when you modified contents\n   */\n  update() {\n    update(this);\n\n    this._plugins.forEach((plugin) => {\n      plugin.onUpdate();\n    });\n  }\n\n  /**\n   * Checks if an element is visible in the current view area\n   */\n  isVisible(elem: HTMLElement): boolean {\n    return isVisible(this, elem);\n  }\n\n  /**\n   * Sets the scrollbar to the given offset without easing\n   */\n  setPosition(\n    x = this.offset.x,\n    y = this.offset.y,\n    options: Partial<I.SetPositionOptions> = {},\n  ) {\n    const status = setPosition(this, x, y);\n\n    if (!status || options.withoutCallbacks) {\n      return;\n    }\n\n    this._listeners.forEach((fn) => {\n      fn.call(this, status);\n    });\n  }\n\n  /**\n   * Scrolls to given position with easing function\n   */\n  scrollTo(\n    x = this.offset.x,\n    y = this.offset.y,\n    duration = 0,\n    options: Partial<I.ScrollToOptions> = {},\n  ) {\n    scrollTo(this, x, y, duration, options);\n  }\n\n  /**\n   * Scrolls the target element into visible area of scrollbar,\n   * likes the DOM method `element.scrollIntoView().\n   */\n  scrollIntoView(\n    elem: HTMLElement,\n    options: Partial<I.ScrollIntoViewOptions> = {},\n  ) {\n    scrollIntoView(this, elem, options);\n  }\n\n  /**\n   * Adds scrolling listener\n   */\n  addListener(fn: I.ScrollListener) {\n    if (typeof fn !== 'function') {\n      throw new TypeError('[smooth-scrollbar] scrolling listener should be a function');\n    }\n\n    this._listeners.add(fn);\n  }\n\n  /**\n   * Removes listener previously registered with `scrollbar.addListener()`\n   */\n  removeListener(fn: I.ScrollListener) {\n    this._listeners.delete(fn);\n  }\n\n  /**\n   * Adds momentum and applys delta transformers.\n   */\n  addTransformableMomentum(\n    x: number,\n    y: number,\n    fromEvent: Event,\n    callback?: I.AddTransformableMomentumCallback,\n  ) {\n    this._updateDebounced();\n\n    const finalDelta = this._plugins.reduce((delta, plugin) => {\n      return plugin.transformDelta(delta, fromEvent) || delta;\n    }, { x, y });\n\n    const willScroll = !this._shouldPropagateMomentum(finalDelta.x, finalDelta.y);\n\n    if (willScroll) {\n      this.addMomentum(finalDelta.x, finalDelta.y);\n    }\n\n    if (callback) {\n      callback.call(this, willScroll);\n    }\n  }\n\n  /**\n   * Increases scrollbar's momentum\n   */\n  addMomentum(x: number, y: number) {\n    this.setMomentum(\n      this._momentum.x + x,\n      this._momentum.y + y,\n    );\n  }\n\n  /**\n   * Sets scrollbar's momentum to given value\n   */\n  setMomentum(x: number, y: number) {\n    if (this.limit.x === 0) {\n      x = 0;\n    }\n    if (this.limit.y === 0) {\n      y = 0;\n    }\n\n    if (this.options.renderByPixels) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n\n    this._momentum.x = x;\n    this._momentum.y = y;\n  }\n\n  /**\n   * Update options for specific plugin\n   *\n   * @param pluginName Name of the plugin\n   * @param [options] An object includes the properties that you want to update\n   */\n  updatePluginOptions(pluginName: string, options?: any) {\n    this._plugins.forEach((plugin) => {\n      if (plugin.name === pluginName) {\n        Object.assign(plugin.options, options);\n      }\n    });\n  }\n\n  destroy() {\n    const {\n      containerEl,\n      contentEl,\n    } = this;\n\n    clearEventsOn(this);\n    this._listeners.clear();\n\n    this.setMomentum(0, 0);\n    cancelAnimationFrame(this._renderID);\n\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n\n    scrollbarMap.delete(this.containerEl);\n\n    // restore contents\n    const childNodes = Array.from(contentEl.childNodes);\n\n    while (containerEl.firstChild) {\n      containerEl.removeChild(containerEl.firstChild);\n    }\n\n    childNodes.forEach((el) => {\n      containerEl.appendChild(el);\n    });\n\n    // reset scroll position\n    setStyle(containerEl, {\n      overflow: '',\n    });\n    containerEl.scrollTop = this.scrollTop;\n    containerEl.scrollLeft = this.scrollLeft;\n\n    // invoke plugin.onDestroy\n    this._plugins.forEach((plugin) => {\n      plugin.onDestroy();\n    });\n    this._plugins.length = 0;\n  }\n\n  private _init() {\n    this.update();\n\n    // init evet handlers\n    Object.keys(eventHandlers).forEach((prop) => {\n      eventHandlers[prop](this);\n    });\n\n    // invoke `plugin.onInit`\n    this._plugins.forEach((plugin) => {\n      plugin.onInit();\n    });\n\n    this._render();\n  }\n\n  @debounce(100, { leading: true })\n  private _updateDebounced() {\n    this.update();\n  }\n\n  // check whether to propagate monmentum to parent scrollbar\n  // the following situations are considered as `true`:\n  //         1. continuous scrolling is enabled (automatically disabled when overscroll is enabled)\n  //         2. scrollbar reaches one side and is not about to scroll on the other direction\n  private _shouldPropagateMomentum(deltaX = 0, deltaY = 0): boolean {\n    const {\n      options,\n      offset,\n      limit,\n    } = this;\n\n    if (!options.continuousScrolling) return false;\n\n    // force an update when scrollbar is \"unscrollable\", see #106\n    if (limit.x === 0 && limit.y === 0) {\n      this._updateDebounced();\n    }\n\n    const destX = clamp(deltaX + offset.x, 0, limit.x);\n    const destY = clamp(deltaY + offset.y, 0, limit.y);\n    let res = true;\n\n    // offsets are not about to change\n    // `&=` operator is not allowed for boolean types\n    res = res && (destX === offset.x);\n    res = res && (destY === offset.y);\n\n    // current offsets are on the edge\n    res = res && (offset.x === limit.x || offset.x === 0 || offset.y === limit.y || offset.y === 0);\n\n    return res;\n  }\n\n  private _render() {\n    const {\n      _momentum,\n    } = this;\n\n    if (_momentum.x || _momentum.y) {\n      const nextX = this._nextTick('x');\n      const nextY = this._nextTick('y');\n\n      _momentum.x = nextX.momentum;\n      _momentum.y = nextY.momentum;\n\n      this.setPosition(nextX.position, nextY.position);\n    }\n\n    const remain = { ...this._momentum };\n\n    this._plugins.forEach((plugin) => {\n      plugin.onRender(remain);\n    });\n\n    this._renderID = requestAnimationFrame(this._render.bind(this));\n  }\n\n  private _nextTick(direction: 'x' | 'y'): { momentum: number, position: number } {\n    const {\n      options,\n      offset,\n      _momentum,\n    } = this;\n\n    const current = offset[direction];\n    const remain = _momentum[direction];\n\n    if (Math.abs(remain) <= 0.1) {\n      return {\n        momentum: 0,\n        position: current + remain,\n      };\n    }\n\n    let nextMomentum = remain * (1 - options.damping);\n\n    if (options.renderByPixels) {\n      nextMomentum |= 0;\n    }\n\n    return {\n      momentum: nextMomentum,\n      position: current + remain - nextMomentum,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}